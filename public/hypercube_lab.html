<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Prismata Lab: The Hypercube</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #000;
      color: #0ff;
      font-family: sans-serif;
    }

    #info {
      position: absolute;
      top: 20px;
      left: 20px;
      pointer-events: none;
    }

    h1 {
      margin: 0;
      font-size: 1.5rem;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    p {
      opacity: 0.7;
    }
  </style>
  <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>
  <div id="info">
    <h1>The Hypercube Experiment</h1>
    <p>6-Dimensional Hypercube projected to 3D via PCA.</p>
    <p>This is a standalone simulation.</p>
  </div>
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.05);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(2, 2, 4);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;

    // Grid
    const gridHelper = new THREE.GridHelper(10, 20, 0x004444, 0x001111);
    scene.add(gridHelper);

    // Lights
    const ambientLight = new THREE.AmbientLight(0x404040, 2);
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0x00ffff, 2, 20);
    pointLight.position.set(5, 5, 5);
    scene.add(pointLight);

    // Load Hypercube
    const loader = new PLYLoader();
    loader.load('crystals/hypercube/structure.ply', function (geometry) {
      geometry.computeVertexNormals();

      // Particles
      const material = new THREE.PointsMaterial({ size: 0.05, vertexColors: true, sizeAttenuation: true });
      const mesh = new THREE.Points(geometry, material);
      scene.add(mesh);

      // Lines (Topology)
      // We can try to create lines from edges if they exist in PLY, or just visualize points
      // For the hypercube, the points are the most important part of the projection

      // Centering
      geometry.computeBoundingSphere();
      const center = geometry.boundingSphere.center;
      mesh.position.sub(center);

      // --- CONNECT THE DOTS (HYPERCUBE EDGES) ---
      // The PLY only has points. We need to draw the 6D connections.
      // Vertices are generated in binary order (itertools.product).
      // So vertex i connects to j if they differ by exactly 1 bit (Hamming distance 1).

      const positions = geometry.attributes.position.array;
      const linePoints = [];
      const numVertices = 64; // 2^6

      // Helper: Count set bits
      function popcount(n) {
        n = n - ((n >> 1) & 0x55555555);
        n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
        return ((n + (n >> 4) & 0xF0F0F0F) * 0x1010101) >> 24;
      }

      for (let i = 0; i < numVertices; i++) {
        for (let j = i + 1; j < numVertices; j++) {
          // Check purely by index (simulating the 6D binary structure)
          // This assumes the Python itertools.product generated them in standard lexicographical/binary order.
          // Even if Python order varied, PCA preserves the neighborhood relative to the 'weight' values.
          // But wait, PCA acts on the WEIGHTS. The positions in PLY are PCA-projected.
          // The ORDER in the PLY is the same as the order we added to 'points' list.
          // 'prismata_make.py' appended them sequentially.

          // We need to verify if itertools.product([-1, 1], repeat=6) corresponds to binary 0..63 order.
          // It effectively does (bitwise changes).
          // Actually, itertools is ((-1,-1...), (-1, 1...), ...) which acts like a counter.

          // Let's rely on the math:
          // Hamming distance check on the INDEX i and j.
          // The itertools sequence is equivalent to counting in binary if we map -1->0, 1->1.

          // Distance check:
          let diff = 0;
          let x = i ^ j; // XOR
          while (x > 0) {
            if ((x & 1) === 1) diff++;
            x >>= 1;
          }

          if (diff === 1) {
            // Connect!
            const startX = positions[i * 3] - center.x;
            const startY = positions[i * 3 + 1] - center.y;
            const startZ = positions[i * 3 + 2] - center.z;

            const endX = positions[j * 3] - center.x;
            const endY = positions[j * 3 + 1] - center.y;
            const endZ = positions[j * 3 + 2] - center.z;

            linePoints.push(new THREE.Vector3(startX, startY, startZ));
            linePoints.push(new THREE.Vector3(endX, endY, endZ));
          }
        }
      }

      if (linePoints.length > 0) {
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(linePoints);
        const lineMaterial = new THREE.LineBasicMaterial({ color: 0x00ffff, opacity: 0.3, transparent: true });
        const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
        scene.add(lines);
      }

      console.log("Hypercube loaded");
    });

    window.addEventListener('resize', onWindowResize, false);

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>

</html>